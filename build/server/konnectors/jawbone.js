// Generated by CoffeeScript 1.10.0
var Sleep, Steps, async, buildExistingHashes, cozydb, dataFields, fetcher, getCSVs, localization, log, logIn, moment, querystring, request, saveData;

cozydb = require('cozydb');

querystring = require('querystring');

request = require('request');

moment = require('moment');

async = require('async');

fetcher = require('../lib/fetcher');

localization = require('../lib/localization_manager');

log = require('printit')({
  prefix: "Jawbone",
  date: true
});

dataFields = {
  DATE: "date",
  m_active_time: "activeTime",
  m_calories: "activeTimeCalories",
  m_distance: "distance",
  m_inactive_time: "inactiveTime",
  m_lcat: "longestActiveTime",
  m_lcit: "longestIdleTime",
  m_steps: "steps",
  m_total_calories: "totalCalories",
  s_asleep_time: "asleepTime",
  s_awake: "awakeDuration",
  s_awake_time: "awakeTime",
  s_awakenings: "awakeningCount",
  s_bedtime: "bedTime",
  s_deep: "deepSleepDuration",
  s_duration: "sleepDuration",
  s_light: "lightSleepDuration",
  s_quality: "sleepQuality"
};

Steps = require('../models/steps');

Sleep = require('../models/sleep');

module.exports = {
  name: "Jawbone",
  slug: "jawbone",
  description: 'konnector description jawbone',
  vendorLink: "https://jawbone.com/up",
  category: 'health',
  color: {
    hex: '#1A1919',
    css: '#1A1919'
  },
  fields: {
    login: "text",
    password: "password"
  },
  models: {
    moves: Steps,
    sleeps: Sleep
  },
  init: function(callback) {
    return callback();
  },
  fetch: function(requiredFields, callback) {
    var data, entries;
    entries = {};
    data = {};
    log.info('Import started');
    return fetcher["new"]().use(buildExistingHashes).use(logIn).use(getCSVs).use(saveData).args(requiredFields, entries, data).fetch(function(err, fields, entries, data) {
      var localizationKey, notifContent, options;
      if (err) {
        log.error('An error occured');
        log.raw(err);
      }
      log.info("Import finished");
      notifContent = null;
      if ((entries != null) && (entries.numSteps > 0 || entries.numSleep > 0)) {
        localizationKey = 'notification measures';
        options = {
          smart_count: entries.numSteps + entries.numSleep
        };
        notifContent = localization.t(localizationKey, options);
      }
      return callback(err, notifContent);
    });
  }
};

buildExistingHashes = function(requiredFields, entries, data, next) {
  return Steps.all(function(err, steps) {
    if (err) {
      return next(err);
    }
    return Sleep.all(function(err, sleeps) {
      var date, i, k, len, len1, sleep, step;
      if (err) {
        return next(err);
      }
      entries.stepsHash = {};
      for (i = 0, len = steps.length; i < len; i++) {
        step = steps[i];
        date = moment(step.date).startOf('day').toISOString();
        entries.stepsHash[date] = true;
      }
      entries.sleepHash = {};
      for (k = 0, len1 = sleeps.length; k < len1; k++) {
        sleep = sleeps[k];
        date = moment(sleep.date).startOf('day').toISOString();
        entries.sleepHash[date] = true;
      }
      return next();
    });
  });
};

logIn = function(requiredFields, entries, data, next) {
  var login, options, password, url;
  login = requiredFields.login;
  password = requiredFields.password;
  url = "https://jawbone.com/user/signin/login";
  options = {
    jar: true,
    form: {
      email: login,
      pwd: password,
      service: "nudge"
    }
  };
  log.info('Attempt to log in');
  return request.post(url, options, function(err, res, body) {
    if (err) {
      return next(err);
    } else if (res.statusCode !== 200) {
      return next(new Error("Cannot connect to Jawbone server."));
    } else {
      body = JSON.parse(body);
      if (body.error != null) {
        if (body.error.msg != null) {
          log.error(body.error.msg);
        } else {
          log.error('Bad credentials');
        }
        return next(new Error('bad credentials'));
      } else {
        log.info('Konnector successfully logged in.');
        data.token = body.token;
        return next();
      }
    }
  });
};

getCSVs = function(requiredFields, entries, data, next) {
  var currentYear, i, results;
  currentYear = moment().year();
  entries.columns = {};
  entries.lines = [];
  return async.eachSeries((function() {
    results = [];
    for (var i = 2013; 2013 <= currentYear ? i <= currentYear : i >= currentYear; 2013 <= currentYear ? i++ : i--){ results.push(i); }
    return results;
  }).apply(this), function(year, done) {
    var options, url;
    log.info("import year " + year);
    url = 'https://jawbone.com/user/settings/download_up_data?';
    url += querystring.stringify({
      year: year
    });
    options = {
      jar: true,
      uri: url,
      headers: {
        'x-nudge-token': data.token
      }
    };
    return request.get(options, function(err, res, csvData) {
      var attr, columns, header, headers, j, k, l, len, len1, line, lines, ref;
      if (err) {
        return done(err);
      } else if (res.statusCode !== 200) {
        return done(new Error("Error occured while fetching data"));
      } else {
        lines = csvData.split('\n');
        headers = lines.shift(0);
        columns = {
          date: 0
        };
        j = 0;
        for (k = 0, len = lines.length; k < len; k++) {
          line = lines[k];
          entries.lines.push(line.split(','));
        }
        ref = headers.split(',');
        for (l = 0, len1 = ref.length; l < len1; l++) {
          header = ref[l];
          attr = dataFields[header];
          if (attr != null) {
            columns[attr] = j;
          }
          j++;
        }
        entries.columns[year] = columns;
        log.info("CSV file downloaded for year " + year + ".");
        return done();
      }
    });
  }, function(err) {
    return next(err);
  });
};

saveData = function(requiredFields, entries, data, next) {
  var columns, date, i, len, line, ref, ref1, ref2, sleepToSave, stepsToSave, year;
  log.info("Start saving data.");
  log.info("Checking " + entries.lines.length + " entries.");
  stepsToSave = [];
  sleepToSave = [];
  ref = entries.lines;
  for (i = 0, len = ref.length; i < len; i++) {
    line = ref[i];
    date = moment(line[0], "YYYYMMDD").toISOString();
    year = moment(line[0], "YYYYMMDD").year();
    columns = entries.columns[parseInt(year)];
    if (columns != null) {
      if ((line[columns.steps] != null) && !((ref1 = line[columns.steps]) === '' || ref1 === '0') && !entries.stepsHash[date]) {
        log.info("New steps entry for " + date);
        stepsToSave.push({
          date: date,
          activeTime: line[columns.activeTime],
          activeTimeCalories: line[columns.activeTimeCalories],
          distance: line[columns.distance],
          inactiveTime: line[columns.inactiveTime],
          longestActiveTime: line[columns.longestActiveTime],
          longestIdleTime: line[columns.longestIdleTime],
          steps: line[columns.steps],
          totalCalories: line[columns.totalCalories],
          vendor: 'Jawbone'
        });
      }
      if ((line[columns.asleepTime] != null) && !((ref2 = line[columns.asleepTime]) === '' || ref2 === '0') && !entries.sleepHash[date]) {
        log.info("New sleep entry for " + date);
        sleepToSave.push({
          date: date,
          asleepTime: line[columns.asleepTime],
          awakeDuration: line[columns.awakeDuration],
          awakeTime: line[columns.awakeTime],
          awakeningCount: line[columns.awakeningCount],
          bedTime: line[columns.bedTime],
          deepSleepDuration: line[columns.deepSleepDuration],
          sleepDuration: line[columns.sleepDuration],
          lightSleepDuration: line[columns.lightSleepDuration],
          sleepQuality: line[columns.sleepQuality],
          vendor: 'Jawbone'
        });
      }
    }
  }
  log.info("Save steps to database");
  return async.eachSeries(stepsToSave, function(steps, done) {
    return Steps.create(steps, done);
  }, function(err) {
    if (err) {
      return next(err);
    }
    log.info("Save sleeps to database");
    return async.eachSeries(sleepToSave, function(sleep, done) {
      return Sleep.create(sleep, done);
    }, function(err) {
      var numSleep, numSteps;
      if (err) {
        return next(err);
      }
      entries.numSteps = numSteps = stepsToSave.length;
      entries.numSleep = numSleep = sleepToSave.length;
      log.info(numSteps + " data saved.");
      log.info(numSleep + " data saved.");
      return next();
    });
  });
};
